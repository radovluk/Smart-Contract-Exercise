\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{geometry}
\usepackage{graphicx} % For including graphics

\usepackage{minted} % For advanced code listings

% Define a custom minted style (optional)
\usemintedstyle{colorful} % You can choose from various styles like 'monokai', 'tango', 'colorful', etc.

% Custom color setup
\definecolor{bashtextcolor}{RGB}{0, 0, 0} % Define black color

% Define a new command for inline code using minted
\newcommand{\codeinline}[1]{\mintinline{text}{#1}}

\geometry{a4paper, margin=1in}

\title{Smart Contracts Exercise 03: \\ ERC-20 CTU Token}
\author{}
\date{}

% Define a new command for inline code with a dark background
\newcommand{\codeblack}[1]{%
  \texttt{\colorbox{black!7}{\textcolor{black}{#1}}}%
}

% Define a new command for inline code with a dark background
\newcommand{\codegrey}[1]{%
  \texttt{\colorbox{black!4}{\textcolor{black}{#1}}}%
}

% Define custom colors (optional)
\definecolor{myURLColor}{RGB}{0, 102, 204} % Example: A shade of blue

\hypersetup{
    colorlinks=true,        % Enable colored links
    linkcolor=blue,         % Color for internal links (e.g., \ref, \cite)
    citecolor=blue,         % Color for citations
    filecolor=magenta,      % Color for file links
    urlcolor=myURLColor     % Color for external URLs
}

% Define a style for code listings
\lstdefinestyle{mystyle}{
    backgroundcolor=\color{lightgray!20},   
    commentstyle=\color{green!50!black},
    keywordstyle=\color{blue},
    numberstyle=\tiny\color{gray},
    stringstyle=\color{red},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}
% Adding package for header and footer
\usepackage{fancyhdr}
\pagestyle{fancy}

% Define header and footer
\fancyhf{} % Clear current settings
\fancyhead[L]{Smart Contracts Exercise 03} % Left header
\fancyhead[R]{\thepage} % Right header with page number

\renewcommand{\headrulewidth}{0.4pt} % Line below header
% \renewcommand{\footrulewidth}{0.4pt} % Line above footer

\begin{document}

\maketitle
\section{Introduction}

Tokens in the Ethereum ecosystem are smart contracts that implement a standardized interface. They are designed to virtually represent certain assets. For example, financial assets such as shares in a company, use as cryptocurrencies (stable coins like USDC, DAI), allow holders to vote on decisions in decentralized projects (e.g., Uniswap - UNI), enable artists to tokenize their works and sell them as unique digital items (NFTs), represent collectibles in games, or are used for digital identity or access to services. Depending on the use case, there are different types of tokens, each serving different purposes. Below are three common types of tokens:

\begin{enumerate}
  \item \textbf{Fungible Tokens}

  Fungible tokens \href{https://eips.ethereum.org/EIPS/eip-20}{(\textit{ERC-20 Tokens})} are interchangeable and have exactly the same value. Each unit of a fungible token is identical to another unit. Examples are cryptocurrencies, utility tokens or governance tokens.

    \begin{figure}[h!]
      \centering
      \includegraphics[width=0.5\textwidth]{fungible-tokens.pdf}
      \caption{Fungible Tokens}
      \label{fig:fungible-tokens}
    \end{figure}

    \item \textbf{Non-Fungible Tokens (NFTs)}

    Non-fungible tokens \href{https://eips.ethereum.org/EIPS/eip-721}{(\textit{ERC-721 Tokens})} are unique and cannot be exchanged on a one-to-one basis. They are used to represent ownership of unique items such as digital art, collectibles, and real estate. Each token is uniquely identifiable by an ID.

    \begin{figure}[h!]
      \centering
      \includegraphics[width=0.5\textwidth]{non-fungible-tokens.pdf}
      \caption{Non-Fungible Tokens}
      \label{fig:non-fungible-tokens}
    \end{figure}

    \item \textbf{Multi-Tokens}

    Multi-tokens \href{https://eips.ethereum.org/EIPS/eip-1155}{(\textit{ERC-1155 Tokens})} combine the properties of both fungible and non-fungible tokens. They allow for the creation of multiple token types within a single contract, providing flexibility for various use cases.

    \begin{figure}[h!]
      \centering
      \includegraphics[width=0.5\textwidth]{multi-token.pdf}
      \caption{Multi-Tokens}
      \label{fig:multi-token}
    \end{figure}
  \end{enumerate}

In this exercise, you will create your own ERC-20 token contract according to the specified standard, and then we will attempt to hack this contract together.

\subsection*{Prerequisites}

Ensure that you have already installed the following on your system:

\begin{itemize}
    \item \textbf{Node.js} - \url{https://nodejs.org/en/}
    An open-source, cross-platform, back-end JavaScript runtime environment that runs on the V8 engine and executes JavaScript code outside a web browser. 
    \item \textbf{NPM}: Node Package Manager, which comes with Node.js.
\end{itemize}

Open your terminal and run the following commands to verify the installations:

\begin{minted}[bgcolor=gray!5, fontsize=\footnotesize]{bash}
$ node -v
$ npm -v
\end{minted}

Both commands should return the installed version numbers of Node.js and NPM respectively. Node.js provides the runtime environment required to execute JavaScript-based tools like Hardhat, while NPM is used to manage the packages and dependencies needed for development. It is recommended that you use NPM 7 or higher.

\subsection*{Project Set Up}

To get started, visit the following \href{https://gitlab.fel.cvut.cz/radovluk/smart-contracts-exercises/-/tree/main/03-ERC20-CTUToken/task/task-code}{GitLab repository} and clone it to your local machine. This repository contains a template in which you will complete this exercise. After you clone the repository start with the following command within your project folder:

\begin{minted}[bgcolor=gray!5, fontsize=\footnotesize]{bash}
  $ npm install
\end{minted}
This will install all the necessary dependencies for the project. Your implementation will be in the file \textit{contracts/CTUToken.sol}. In this file, there are \#TODO comments where you should implement the required functionality. To fulfill this task you need to pass all the provided tests. You can run the tests with the following command:

\begin{minted}[bgcolor=gray!5, fontsize=\footnotesize]{bash}
  $ npx hardhat test
\end{minted}

\section{Specification: ERC-20 Token}

The ERC-20 standard was first proposed by Fabian Vogelsteller and Vitalik Buterin in November 2015. The token specification defines the interface that a smart contract must implement to be ERC-20 compliant. It is important to note that it \textbf{does not specify the actual implementation}. It is the most widely used standard with more than 1.5 million smart contracts on the main net implementing it.

Example functionalities ERC-20 provides:

\begin{itemize}
  \item Transfer tokens from one account to another.
  \item Get the current token balance of an account.
  \item Get the total supply of the token available on the network.
  \item Approve whether an amount of token from an account can be spent by a third-party account.
\end{itemize}

If a Smart Contract implements the following methods and events, it can be called an ERC-20 Token Contract. Once deployed, it will be responsible for keeping track of the created tokens on Ethereum. To see the full specification, visit \href{https://eips.ethereum.org/EIPS/eip-20}{EIP20 documentation}.

\subsubsection*{Methods}

\begin{minted}[bgcolor=gray!5, fontsize=\footnotesize]{solidity}
  function name() public view returns (string)
  function symbol() public view returns (string)
  function decimals() public view returns (uint8)
  function totalSupply() public view returns (uint256)
  function balanceOf(address _owner) public view returns (uint256 balance)
  function transfer(address _to, uint256 _value) public returns (bool success)
  function transferFrom(address _from, address _to, uint256 _value) 
    public returns (bool success)
  function approve(address _spender, uint256 _value) public returns (bool success)
  function allowance(address _owner, address _spender) 
    public view returns (uint256 remaining)  
\end{minted}

\subsubsection*{Events}

\begin{minted}[bgcolor=gray!5, fontsize=\footnotesize]{solidity}
  event Transfer(address indexed _from, address indexed _to, uint256 _value)
  event Approval(address indexed _owner, address indexed _spender, uint256 _value)  
\end{minted}

\subsection*{OpenZeppelin}

\href{https://www.openzeppelin.com/}{OpenZeppelin} provides a open-source library for secure smart contract development. It is built on a solid
foundation of community-vetted code. It is good practice to use standardized implementations like those from OpenZeppelin. Documentation about available contracts made by Open Zeppelin can be found \href{https://docs.openzeppelin.com/contracts/4.x/}{here}. The actual implementations of the contracts are available on \href{https://github.com/OpenZeppelin/openzeppelin-contracts}{GitHub}. OpenZeppelin contracts can be installed using npm and imported directly into a contract. The ERC20 implementation by OpenZeppelin is a standard recognized by the official EIP20 documentation. You can find the implementation \href{https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol}{here}. It is a common practice to use the ERC20 implementation by OpenZeppelin when creating ERC20 token contracts, instead of explicitly implementing the ERC20 interface inside the contract. However, for the educational purpose of this exercise, you will implement the ERC20 contract by yourself. The implementation of the CTU Token contract using OpenZeppelin can be seen in the code below.

\begin{minted}[bgcolor=gray!5, fontsize=\footnotesize]{solidity}
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

// Import OpenZeppelin's ERC20 implementation
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

/**
 * @title CTUToken
 * @dev A custom implementation of an ERC-20 Token using OpenZeppelin's library.
 */
contract CTUToken is ERC20 {
    // Define the initial supply: 1,000,000 tokens with 18 decimal places
    uint256 private constant INITIAL_SUPPLY = 1_000_000 * 10 ** 18;

    /**
     * @dev Constructor that initializes the ERC-20 token with a name and symbol,
     * and mints the total supply to the deployer's address.
     */
    constructor() ERC20("CTU Token", "CTU") {
        // Mint the initial supply to the deployer of the contract
        _mint(msg.sender, INITIAL_SUPPLY);
    }
}
\end{minted}

\section{CTU Token}

To complete the CTU Token contract and pass all the associated tests, you need to implement the required functionality in the \textit{contracts/CTUToken.sol} file. Look for the sections marked with \#TODO comments and ensure that all the specified requirements bellow are met.

\subsection*{Token Details}
\begin{itemize}
    \item \textbf{Name}: Set the token name to \texttt{"CTU Token"}.
    \item \textbf{Symbol}: Set the token symbol to \texttt{"CTU"}.
    \item \textbf{Decimals}: Use \texttt{18} decimal places to align with the standard Ether denomination.
    \item \textbf{Total Supply}: Initialize the total supply to \texttt{1,000,000} tokens.
\end{itemize}

\subsection*{Events}
\begin{itemize}
    \item \textbf{Transfer Event}: Emit a \texttt{Transfer} event whenever tokens are transferred, including zero-value transfers.
    \item \textbf{Approval Event}: Implement and emit an \texttt{Approval} event when an allowance is set via the \texttt{approve} function.
\end{itemize}

\subsection*{State Variables}
\begin{itemize}
    \item \textbf{Balances Mapping}: Maintain a \texttt{mapping(address => uint256)} to track the token balance of each account.
    \item \textbf{Allowances Mapping}: Use a nested \texttt{mapping(address => mapping(address => uint256))} to manage allowances, enabling accounts to authorize others to spend tokens on their behalf.
\end{itemize}

\subsection*{Constructor}
\begin{itemize}
    \item Assign the entire \texttt{totalSupply} to the contract deployer's address upon deployment.
\end{itemize}

\subsection*{Core Functions}
\begin{itemize}
    \item \textbf{name()}: Return the name of the token.
    \item \textbf{symbol()}: Return the token symbol.
    \item \textbf{decimals()}: Return the number of decimal places (\texttt{18}).
    \item \textbf{totalSupply()}: Return the total supply of tokens in existence.
    \item \textbf{balanceOf(address account)}: Return the token balance of the specified account.
    \item \textbf{transfer(address to, uint256 value)}:
    \begin{itemize}
        \item Ensure the recipient address is not the zero address.
        \item Verify that the sender has a sufficient balance.
        \item Update the sender's and recipient's balances accordingly.
        \item Emit a \texttt{Transfer} event.
    \end{itemize}
    \item \textbf{approve(address spender, uint256 value)}:
    \begin{itemize}
        \item Ensure the spender address is not the zero address.
        \item Set the allowance for the spender.
        \item Emit an \texttt{Approval} event.
    \end{itemize}
    \item \textbf{allowance(address owner, address spender)}: Return the remaining number of tokens that the spender is allowed to spend on behalf of the owner.
    \item \textbf{transferFrom(address from, address to, uint256 value)}:
    \begin{itemize}
        \item Ensure neither the sender nor the recipient is the zero address.
        \item Verify that the source account has a sufficient balance.
        \item Check that the caller has enough allowance.
        \item Update the balances of the source and recipient accounts.
        \item Decrease the allowance accordingly.
        \item Emit a \texttt{Transfer} event.
    \end{itemize}
\end{itemize}

To fulfill the exercise, you need to pass all the provided tests. You can run the tests with the following command:
\begin{minted}[bgcolor=gray!5, fontsize=\footnotesize]{bash}
  $ npx hardhat test
\end{minted}

\section{Frontrunning Attack}

Did your contract pass all the tests? Congratulations! It is now fully tested and it is time to deploy your brand new CTU token to the main net. But is it really?

\begin{figure}[h!]
\centering
\includegraphics[width=0.9\textwidth]{sandwich.pdf}
% \caption{Frontrunning Attack}
\label{fig:frontrunning}
\end{figure}

\end{document}
